import JSZip from "jszip";
import { saveAs } from "file-saver";
import { jsPDF } from "jspdf";
import type { PlatformPrompts, PlatformKey } from "./styleExtractionClient";

export interface GeneratedImage {
  url: string;
  platform: PlatformKey;
  timestamp: number;
}

interface PlatformConfig {
  label: string;
  fullModelName?: string;
}

const PLATFORM_CONFIG: Record<PlatformKey, PlatformConfig> = {
  gpt_image: { label: "GPT Image", fullModelName: "OpenAI GPT Image 1.5" },
  flux: { label: "Flux", fullModelName: "Black Forest Labs Flux 2 Pro" },
  nano_banana: { label: "Nano Banana", fullModelName: "Google Imagen 3 (Nano Banana Pro)" },
  seedream: { label: "Seedream", fullModelName: "ByteDance Seedream 4.5" },
};

const PLATFORM_ORDER: PlatformKey[] = ["gpt_image", "flux", "nano_banana", "seedream"];

function formatDate(date: Date): string {
  return date.toISOString().split("T")[0];
}

function formatDateTime(date: Date): string {
  return date.toISOString().replace("T", " ").split(".")[0];
}

function getPlatformFilename(platform: PlatformKey): string {
  return platform.replace(/_/g, "-");
}

function generatePromptTextFile(platform: PlatformKey, prompt: string): string {
  const config = PLATFORM_CONFIG[platform];
  const modelName = config.fullModelName ? ` (${config.fullModelName})` : "";
  const now = new Date();

  return `Platform: ${config.label}${modelName}
Generated: ${formatDateTime(now)}

PROMPT:
${prompt}
`;
}

function generateReadme(
  prompts: PlatformPrompts,
  generatedImages: GeneratedImage[],
  sourceImageCount: number
): string {
  const now = new Date();
  const lines: string[] = [
    "# Style Prompts Export",
    "",
    `**Generated:** ${formatDateTime(now)}`,
    `**Source Images:** ${sourceImageCount}`,
    "",
    "---",
    "",
    "## Prompts",
    "",
  ];

  // Create a map of platform to image filename
  const imageMap = new Map<PlatformKey, string>();
  for (const image of generatedImages) {
    const filename = `${getPlatformFilename(image.platform)}-${image.timestamp}.png`;
    imageMap.set(image.platform, filename);
  }

  for (const platform of PLATFORM_ORDER) {
    const prompt = prompts[platform];
    if (!prompt) continue;

    const config = PLATFORM_CONFIG[platform];
    const modelName = config.fullModelName ? ` (${config.fullModelName})` : "";
    
    lines.push(`### ${config.label}${modelName}`);
    lines.push("");

    // Add image reference if exists
    const imageFilename = imageMap.get(platform);
    if (imageFilename) {
      lines.push(`![${config.label} Generated Image](images/${imageFilename})`);
      lines.push("");
    } else {
      lines.push("*No image generated*");
      lines.push("");
    }

    lines.push("```");
    lines.push(prompt);
    lines.push("```");
    lines.push("");
  }

  lines.push("---");
  lines.push("");
  lines.push("*Generated by [imgPrompter](https://imgprompter.com)*");

  return lines.join("\n");
}

async function generatePDF(
  prompts: PlatformPrompts,
  generatedImages: GeneratedImage[],
  sourceImageCount: number
): Promise<Blob> {
  const doc = new jsPDF({
    orientation: "portrait",
    unit: "mm",
    format: "a4",
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - margin * 2;
  let y = margin;

  // Title
  doc.setFontSize(24);
  doc.setFont("helvetica", "bold");
  doc.text("Style Prompts Export", pageWidth / 2, y, { align: "center" });
  y += 15;

  // Metadata
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(100);
  doc.text(`Generated: ${formatDateTime(new Date())}`, pageWidth / 2, y, { align: "center" });
  y += 5;
  doc.text(`Source Images: ${sourceImageCount}`, pageWidth / 2, y, { align: "center" });
  y += 15;
  doc.setTextColor(0);

  // Create image map
  const imageDataMap = new Map<PlatformKey, string>();
  for (const image of generatedImages) {
    try {
      const response = await fetch(image.url);
      const blob = await response.blob();
      const base64 = await blobToBase64(blob);
      imageDataMap.set(image.platform, base64);
    } catch (error) {
      console.error(`Failed to load image for ${image.platform}:`, error);
    }
  }

  // Add each platform section
  for (const platform of PLATFORM_ORDER) {
    const prompt = prompts[platform];
    if (!prompt) continue;

    const config = PLATFORM_CONFIG[platform];
    const modelName = config.fullModelName ? ` (${config.fullModelName})` : "";

    // Check if we need a new page
    if (y > pageHeight - 80) {
      doc.addPage();
      y = margin;
    }

    // Platform header
    doc.setFontSize(14);
    doc.setFont("helvetica", "bold");
    doc.text(`${config.label}${modelName}`, margin, y);
    y += 8;

    // Add image if exists
    const imageData = imageDataMap.get(platform);
    if (imageData) {
      const imgSize = 50; // 50mm square
      try {
        doc.addImage(imageData, "PNG", margin, y, imgSize, imgSize);
        
        // Add prompt text next to image
        doc.setFontSize(9);
        doc.setFont("helvetica", "normal");
        const textX = margin + imgSize + 5;
        const textWidth = contentWidth - imgSize - 5;
        const lines = doc.splitTextToSize(prompt, textWidth);
        const maxLines = Math.min(lines.length, 12); // Limit lines to fit next to image
        doc.text(lines.slice(0, maxLines), textX, y + 5);
        if (lines.length > maxLines) {
          doc.text("...", textX, y + 5 + maxLines * 4);
        }
        y += imgSize + 10;
      } catch {
        // If image fails, just show prompt
        doc.setFontSize(9);
        doc.setFont("helvetica", "normal");
        const lines = doc.splitTextToSize(prompt, contentWidth);
        doc.text(lines.slice(0, 8), margin, y);
        y += Math.min(lines.length, 8) * 4 + 10;
      }
    } else {
      // No image - just show prompt
      doc.setFontSize(9);
      doc.setFont("helvetica", "normal");
      const lines = doc.splitTextToSize(prompt, contentWidth);
      doc.text(lines.slice(0, 8), margin, y);
      y += Math.min(lines.length, 8) * 4 + 10;
    }
  }

  // Footer
  doc.setFontSize(8);
  doc.setTextColor(150);
  doc.text("Generated by imgPrompter", pageWidth / 2, pageHeight - 10, { align: "center" });

  return doc.output("blob");
}

function blobToBase64(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const result = reader.result as string;
      resolve(result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

export interface ExportOptions {
  prompts: PlatformPrompts;
  generatedImages: GeneratedImage[];
  sourceImageCount: number;
}

export async function createExportZip(options: ExportOptions): Promise<void> {
  const { prompts, generatedImages, sourceImageCount } = options;
  const zip = new JSZip();
  const dateStr = formatDate(new Date());

  // Create folders
  const imagesFolder = zip.folder("images");
  const promptsFolder = zip.folder("prompts");

  if (!imagesFolder || !promptsFolder) {
    throw new Error("Failed to create ZIP folders");
  }

  // Add images
  for (const image of generatedImages) {
    try {
      const response = await fetch(image.url);
      const blob = await response.blob();
      const filename = `${getPlatformFilename(image.platform)}-${image.timestamp}.png`;
      imagesFolder.file(filename, blob);
    } catch (error) {
      console.error(`Failed to fetch image for ${image.platform}:`, error);
    }
  }

  // Add prompt text files for all platforms
  for (const platform of PLATFORM_ORDER) {
    const prompt = prompts[platform];
    if (prompt) {
      const filename = `${getPlatformFilename(platform)}.txt`;
      const content = generatePromptTextFile(platform, prompt);
      promptsFolder.file(filename, content);
    }
  }

  // Add README.md
  const readme = generateReadme(prompts, generatedImages, sourceImageCount);
  zip.file("README.md", readme);

  // Add PDF summary
  try {
    const pdfBlob = await generatePDF(prompts, generatedImages, sourceImageCount);
    zip.file("summary.pdf", pdfBlob);
  } catch (error) {
    console.error("Failed to generate PDF:", error);
    // Continue without PDF if it fails
  }

  // Generate and download ZIP
  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, `style-prompts-${dateStr}.zip`);
}
